---
interact_link: content/03/4/leadc.ipynb
kernel_name: matlab
kernel_path: content/03/4
has_widgets: false
title: |-
  Lead compensation
pagenum: 11
prev_page:
  url: /03/3/pplusd.html
next_page:
  url: /03/5/analrloc.html
suffix: .ipynb
search: s lead pole compensator left frac angle zero gain right loop j closed p frequency d z figure desired matlab high g mathrm contribution omega problem system line location method root locus should control design compensation real poles criterion kc type origin step satellite attitude circ feedback cascade derivative pd response low ratio limits point images fig png dazzo houpis cancel example plant graphical drawn using c third not proportional effects such cannot any k infty still plane illustrated phic positive relative closest cancelled following transfer function gives note between given construction locating follows locate through lines axis obtained calculated

comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---

    <main class="jupyter-page">
    <div id="page-info"><div id="page-title">Lead compensation</div>
</div>
    <div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Lecturer</strong></p>
<p>Set up MATLAB</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">cd </span><span class="s">matlab</span><span class="p"></span>
<span class="n">pwd</span>
<span class="s">clear all</span><span class="p"></span>
<span class="n">format </span><span class="s">compact</span><span class="p"></span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
ans =

    &#39;/Users/eechris/dev/eglm03-textbook/content/03/4/matlab&#39;

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Cascade-Lead-compensation">Cascade Lead compensation<a class="anchor-link" href="#Cascade-Lead-compensation"> </a></h1>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Introduction">Introduction<a class="anchor-link" href="#Introduction"> </a></h2><p>The proportional plus derivative compensator has the unfortunate property that its high frequency gain is infinite. This means that high frequency effects, such as sensor noise and un-modelled high-frequency dynamics, e.g. resonance terms, will be amplified with potentially disastrous effects. Of course, a real physical derivative operator cannot be implemented and any implementation will actually have poles that will limit the high-frequency gain.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Recognizing this, an alternative to the pure P+D</p>
$$D_{\mathrm{P+D}}=K_D s + K_{\mathrm{prop}}$$<p>is the so-called "lead compensator"</p>
$$D_{\rm{lead}}(s) = {K_c}\left( \frac{s - z_0}{s - p_0}\right)$$<p>where</p>
$$|p_0| &gt; |z_0|.$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Considering the frequency response of $D_{\mathrm{lead}}$</p>
$$D_{\mathrm{lead}}(j\omega)
=  K_c\left(\frac{j\omega-z_0}{j\omega-p_0}\right)$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The low and high-frequency gains are:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
$$\left.D_{\mathrm{lead}}(j\omega)\right|_{\omega\to 0} = Kc \left(\frac{z_0}{p_0}\right)$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
$$\left.D_{\mathrm{lead}}(j\omega)\right|_{\omega\to \infty} = Kc$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>so that the ratio of high-to-low frequency gain is</p>
$$\frac{D_{\mathrm{lead}}(j\infty)}{D_{\mathrm{lead}}(j0)}=\frac{p_0}{z_0}&gt;0$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The lead compensator is still a high-pass filter but the pole at $s=p_0$
limits the high frequency gain. Typically, the ratio of $p_0$ to $z_0$ is kept
to below 10.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Properties-of-the-Cascade-Lead-Compensator">Properties of the Cascade Lead Compensator<a class="anchor-link" href="#Properties-of-the-Cascade-Lead-Compensator"> </a></h2><p>As  $|p_0| &gt; |z_0|$, the angle contributed by the compensator to some arbitrary
point $s_1$ at on the <em>s</em>-plane is illustrated in Figure 1.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="images/fig1.png" alt="Figure 1"></p>
<p><strong>Figure 1 Angle contribution of a lead compensator</strong></p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The net contribution is</p>
$$\phi_c = \theta_z - \theta_p &gt; 0$$<p>so that the lead compensator always makes a positive contribution to the
angle criterion.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This has the effect of allowing the closed-loop poles to move
to the left in the s-plane.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The problem is then how to choose the relative location of the pole and the zero.</p>
<p>We reproduce the advice of D'Azzo and Houpis (1975).</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Method-1">Method 1<a class="anchor-link" href="#Method-1"> </a></h2><p>Use the zero to cancel a low frequency real pole. This can simplify the root locus and reduce the complexity of the problem. The compensator pole is then placed such that $s_1$ becomes a point on the desired root-locus.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For a Type 1 system, the real pole (excluding the pole at zero) that is closest to the origin should be cancelled.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For a Type 0 system, the second closest pole to the origin should be cancelled.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example-1">Example 1<a class="anchor-link" href="#Example-1"> </a></h3><p>The following Matlab code illustrates these principles for the system with</p>
<p>Type 1 open-loop transfer function</p>
$$G_1(s) = \frac{1}{s(s + 1)}$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Define the plant</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">G1</span> <span class="p">=</span> <span class="n">tf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">conv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]));</span> <span class="n">H</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Plot root-locus</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">rlocus</span><span class="p">(</span><span class="n">G1</span><span class="o">*</span><span class="n">H</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../../images/03/4/leadc_23_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Clearly, we cannot achieve a closed-loop pole at $s_1 = -2 + j2$ without some dynamic compensation.</p>
<p>However, if we use the zero of a cascade lead compensator to cancel the pole at $s = -1$ and place the pole at $s = -4$ we get:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">D1</span> <span class="p">=</span> <span class="n">zpk</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Go1</span> <span class="p">=</span> <span class="n">D1</span><span class="o">*</span><span class="n">G1</span><span class="o">*</span><span class="n">H</span><span class="p">;</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">rlocus</span><span class="p">(</span><span class="n">Go1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../../images/03/4/leadc_26_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>which will have a closed-loop pole at the desired location when the gain is</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">Kc</span> <span class="p">=</span> <span class="n">rlocfind</span><span class="p">(</span><span class="n">Go1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="o">+</span>2<span class="nb">j</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Kc =
     8
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example-2">Example 2<a class="anchor-link" href="#Example-2"> </a></h3><p>For a Type 0 system</p>
$$G_2(s) = \frac{1}{(s + 1)(s + 2)}$$<p>the zero should be used to cancel the pole at $s=-2$. We leave it as an
exercise to prove that the compensator</p>
$$D_2(s)=5\left(\frac{s+2}{s+3}\right)$$<p>gives the desired closed-loop poles.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Note</em></p>
<p>You should be aware that the lead compensator zero will still appear in the closed-loop transfer function, and you should verify that the closed-loop step response is acceptible.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Method-2">Method 2<a class="anchor-link" href="#Method-2"> </a></h2><p>The following graphical method maximizes the ratio between pole and zero for
any given angle contribution. This minimizes the additional compensator gain
needed to satisfy the gain criterion.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="images/fig2.png" alt="Figure 2 Graphical construction for locating the pole and zero of a lead compensator">
<em>Figure 2 Graphical construction for locating the pole and zero of a lead compensator.</em></p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The steps in the location of the lead-compensator pole and zero are as follows (refer to Figure 2).</p>
<ul>
<li>Locate the desired closed-loop pole $s_1$. Draw a line from the origin to
$s_1$ and a horizontal line through $s_1$ to the left.</li>
</ul>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Bisect the angle between the two lines drawn in step 1.</li>
</ul>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Measure the angle $\phi_c$ either side of the line drawn in step 2.</li>
</ul>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>The intersections of these lines with the real axis locate the compensator
pole $p_0$ and zero $z_0$.</li>
</ul>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example-3">Example 3<a class="anchor-link" href="#Example-3"> </a></h3><p>We return to the satellite attitude control problem with</p>
$$G(s) = \frac{1}{s^2}$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Requiring a closed-loop pole $S_1 = -2 + j2$, the geometry of the problem is illustrated in Figure 3.</p>
<p><img src="images/fig3.png" alt="Figure 3 Lead compensator design for the satellite attitude control problem">
<em>Figure 3 Lead compensator design for the satellite attitude control problem.</em></p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that the line drawn from the origin to the point s1 subtends an angle
of $135^\circ$ to the positive real axis.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can use MATLAB to help to work through the trigonometry. The angle contribution
of the plant and feedback at $s_1$ is obtained as follows.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">tf</span><span class="p">(</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">H</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">GH</span> <span class="p">=</span> <span class="n">G</span><span class="o">*</span><span class="n">H</span><span class="p">;</span>
<span class="n">s1</span> <span class="p">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">+</span>2<span class="nb">j</span><span class="p">;</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The total contribution of the plant poles and zeros can be calculated
directly using the Matlab equivalent of the angle criterion</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="p">[</span><span class="nb">zeros</span><span class="p">,</span><span class="n">poles</span><span class="p">,</span><span class="n">gain</span><span class="p">]=</span><span class="n">zpkdata</span><span class="p">(</span><span class="n">GH</span><span class="p">,</span><span class="s">&#39;v&#39;</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>contribution in degrees</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">contrib</span> <span class="p">=</span> <span class="p">(</span><span class="mi">180</span><span class="o">/</span><span class="nb">pi</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="nb">angle</span><span class="p">(</span><span class="n">s1</span> <span class="o">-</span> <span class="nb">zeros</span><span class="p">))</span> <span class="o">-</span> <span class="n">sum</span><span class="p">(</span><span class="nb">angle</span><span class="p">(</span><span class="n">s1</span> <span class="o">-</span> <span class="n">poles</span><span class="p">)))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
contrib =

  -270

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The root locus angle criterion gives lead contribution</p>
$$\begin{array}{c}\angle G({s_1})H({s_1}) + {\phi _c} =  - {180^ \circ
}\\{\phi _c} =  - {180^ \circ } - \angle G({s_1})H({s_1})\end{array}$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">phi_c</span> <span class="p">=</span> <span class="o">-</span><span class="mi">180</span> <span class="o">-</span> <span class="n">contrib</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
phi_c =

    90

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">half_phi_c</span> <span class="p">=</span> <span class="n">phi_c</span><span class="o">/</span><span class="mi">2</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
half_phi_c =

    45

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Because the line BA and OD are parallel, the angle subtended by the line OAB is also $135^\circ$. Thus</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">angle_OAB</span> <span class="p">=</span> <span class="mi">135</span><span class="p">;</span>
<span class="n">angle_BAD</span> <span class="p">=</span> <span class="n">angle_OAB</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">half_phi_c</span><span class="p">;</span>
<span class="n">angle_BEO</span> <span class="p">=</span> <span class="n">angle_OAB</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">half_phi_c</span><span class="p">;</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>and by parallel line theory</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">theta_p</span> <span class="p">=</span> <span class="n">angle_BAD</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
theta_p =

   22.5000

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">theta_z</span> <span class="p">=</span> <span class="n">angle_BEO</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
theta_z =

  112.5000

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The pole and zero locations are given by</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">p0</span> <span class="p">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="nb">tan</span><span class="p">(</span><span class="n">theta_p</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
p0 =

   -6.8284

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">z0</span> <span class="p">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="nb">tan</span><span class="p">(</span><span class="n">theta_z</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
z0 =

   -1.1716

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The compensator gain is obtained using the gain criterion. With MATLAB,
this can be calculated directly from the gain formula:</p>
$${K_0} = \left( \frac{\left| s_1 - p_0 \right|}{\left| s - z_0
\right|} \right)\left( \frac{\prod\limits_{i = 1}^{n - 1} \left| s_1
- p_i \right| }{\prod\limits_{j = 1}^{n - 1} \left| s_1 - z_j \right|}
 \right)$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">Ko</span> <span class="p">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">p0</span><span class="p">)</span><span class="o">*</span><span class="n">prod</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">poles</span><span class="p">)))</span><span class="o">/</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">z0</span><span class="p">)</span><span class="o">*</span><span class="n">prod</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="nb">zeros</span><span class="p">)))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
Ko =

   19.3137

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let us also check this result using the root locus.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">D</span> <span class="p">=</span> <span class="n">zpk</span><span class="p">(</span><span class="n">z0</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Go</span><span class="p">=</span><span class="n">D</span><span class="o">*</span><span class="n">GH</span><span class="p">;</span>
<span class="n">rlocus</span><span class="p">(</span><span class="n">Go</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../../images/03/4/leadc_60_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">Kc</span> <span class="p">=</span> <span class="n">rlocfind</span><span class="p">(</span><span class="n">Go</span><span class="p">,</span><span class="n">s1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
Kc =

   19.3137

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, let us calculate the step response and compare it with the result
achieved with velocity feedback</p>
$$G_1(s) = \frac{8}{s^2 + 4s + 8}$$<p>and proportional + derivative compensation</p>
$$G_2(s) = \frac{4(s+2)}{s^2 + 4s + 8}$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">G1</span> <span class="p">=</span> <span class="n">tf</span><span class="p">(</span><span class="mi">8</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]);</span>
<span class="n">G2</span> <span class="p">=</span> <span class="n">tf</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]);</span>
<span class="n">G3</span> <span class="p">=</span> <span class="n">feedback</span><span class="p">(</span><span class="n">Kc</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">G</span><span class="p">,</span><span class="n">H</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
G3 =
 
      19.314 (s+1.172)
  ------------------------
  (s+2.828) (s^2 + 4s + 8)
 
Continuous-time zero/pole/gain model.

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">t1</span><span class="p">]=</span><span class="n">step</span><span class="p">(</span><span class="n">G1</span><span class="p">);</span>
<span class="p">[</span><span class="n">y2</span><span class="p">,</span><span class="n">t2</span><span class="p">]=</span><span class="n">step</span><span class="p">(</span><span class="n">G2</span><span class="p">);</span>
<span class="p">[</span><span class="n">y3</span><span class="p">,</span><span class="n">t3</span><span class="p">]=</span><span class="n">step</span><span class="p">(</span><span class="n">G3</span><span class="p">);</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">t3</span><span class="p">,</span><span class="n">y3</span><span class="p">),</span><span class="n">legend</span><span class="p">(</span><span class="s">&#39;Velocity fb&#39;</span><span class="p">,</span><span class="s">&#39;P+D&#39;</span><span class="p">,</span><span class="s">&#39;cascade lead&#39;</span><span class="p">),</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Lead compensation: Comparison of results&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../../images/03/4/leadc_64_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>When evaluating the third design you should take into account the location of the compensator zero and the third closed-loop pole (at $s = -2.828$) relative to the desired closed-loop pole at $s_1$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Method-3">Method 3<a class="anchor-link" href="#Method-3"> </a></h2><p>The third method referenced in D'Azzo and Houpis addresses a problem with lead compensator design that has so far not been addressed. That is that only the desired transient performance, and hence the desired location of the dominant closed-loop poles, is considered. The desired system gain is not specified. A method of achieving both gain and desired pole location has been proposed by Phillips and Harbour (1988) and is considered in the <a href="../5/analrloc">Analytic Root Locus Design</a> section (<strong>not assessed</strong>).</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="References">References<a class="anchor-link" href="#References"> </a></h2><p>John J. D'Azzo and Constantne Houpis, (1975) <em>Linear Control System Analysis and Design (Conventional and Modern)</em>, McGraw &amp; Hill, 1975 and later editions.</p>
<p>Phillips and Harbor (1988), <em>Feedback Control Systems</em>, Prentice Hall.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Resources">Resources<a class="anchor-link" href="#Resources"> </a></h2><p>An executable version of this document is available to download as a MATLAB Live Script file <a href="matlab/cclead.mlx">cclead.mlx</a>.</p>
<p>The Simulink model which compares the results of the satellite attitude control system compensated with velocity feedback, P+D compensation <em>and</em> lead compensation is <a href="matlab/lead_compensation.slx">lead_compensation.slx</a>.</p>

</div>
</div>
</div>
</div>

 


    </main>
    